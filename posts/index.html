<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>My Blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="">
    <meta name="generator" content="Hugo 0.105.0-DEV">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/liuyy/ananke/css/main.min.css" >



    
    
    
      

    

    
    
      <link href="/liuyy/posts/index.xml" rel="alternate" type="application/rss+xml" title="My Blog" />
      <link href="/liuyy/posts/index.xml" rel="feed" type="application/rss+xml" title="My Blog" />
      
    
    
    <meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://qiaoqiao321.github.io/liuyy/posts/" />

<meta itemprop="name" content="Posts">
<meta itemprop="description" content=""><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/liuyy/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        My Blog
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Posts
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="pa3 pa4-ns nested-copy-line-height">
    <section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></section>
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/liuyy/posts/my-first-post/" class="link black dim">
        My First Post
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      123456
7891011
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/liuyy/posts/git%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/" class="link black dim">
        git 常见命令总结
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      git 常用命令总结 先附上一张git 的工作原理图：
1、初始化仓库 git init 2、添加本地所有代码，添加到暂存区 git add . 3、提交代码描述 git commit -m &#39;增加新的功能&#39; 4、添加远程仓库，将远程仓库命名为 origin git remote add origin git@github.com:xxxx/xxx.git 5、初始化推送 -u 的含义是将本地仓库关联到远程仓库，简单来说，带上-u 参数其实就相当于记录了push到远端分支的默认值，这样当下次我们还想要继续push的这个远端分支的时候推送命令就可以简写成git push即可
git push -u origin master 6、提交到主分支 git push origin master 7、创建分支 git checkout -b &lt;branchname&gt; # -build 8、查看分支 git branch 9、提交到分支 git push origin dev:将本地的dev 分支push到远程的dev 分支（不是将当前分支！！！！！！！！！！！！！）
如果本地分支与远程分支不同名，那么用这个就会报错。正确命令如下： 1.首先将本地与远程分支成功追踪（track）： git branch &ndash;set-upstream-to=origin/dev_remote:当前分支与远程dev_remote分支绑定 2.推送到远程，注意方式不一样，要多一个 &quot; head: &ldquo;，后面跟分支名 git push origin head:dev_remote 如果在使用了&ndash;set-upstream-to 后要推送到同名分支，可以直接使用git push origin head命令
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/liuyy/posts/go-mod-%E7%9A%84%E4%BD%BF%E7%94%A8/" class="link black dim">
        go mod 的使用
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      go mod 的使用 1、一个包管理工具应该有以下功能： 基本功能
依赖管理 依赖包版本控制 对应的包管理平台 可以私有化部署（不是很懂） 加分：
代码包是否可以复用 构建，测试,打包 发布上线 2、go path 和 go vendor 的问题 go path
代码开发必须在go path src目录下，不然，就有问题。 依赖手动管理 依赖包没有版本可言 从这个看， go path不算包管理工具
go vendor
解决了包依赖，一个配置文件就管理 依赖包全都下载到项目vendor下，每个项目都把有一份。拉取项目时,开始怀疑人生。 3、go mod 介绍 go modules 是 golang 1.11 新加的特性。modules是相关Go包的集合。modules是源代码交换和版本控制的单元。go命令直接支持使用modules，包括记录和解析对其他模块的依赖性。modules替换旧的基于GOPATH的方法来指定在给定构建中使用哪些源文件。
GO111MODULE
GO111MODULE 有三个值：off, on和auto（默认值）。
GO111MODULE=off，go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。GOPATH模式下，依赖包存储在$GOPATH/src，该目录下只保存特定依赖包的一个版本。
GO111MODULE=on，go命令行会使用modules，而不会去GOPATH目录下查找。GOMODULE模式下，依赖包存储在$GOPATH/pkg/mod，该目录中可以存储特定依赖包的多个版本。需要注意的是$GOPATH/pkg/mod目录下有个Cache目录，它用来存储依赖包的缓存，简单说，go命令每次下载新的依赖包都会在该Cache目录中保存一份。
GO111MODULE=auto，默认值，go命令行将会根据当前目录来决定是否启用module功能。这种情况下可以分为两种情形：
当前目录在GOPATH/src之外且该目录包含go.mod文件 当前文件在包含go.mod文件的目录下面。 4、go mod 命令 比较常用的是 go mod init 模块名、go mod tidy、go mod edit
go.mod 提供了module, require、replace和exclude 四个命令
module 语句指定包的名字（路径） require 语句指定的依赖项模块 replace 语句可以替换依赖项模块 exclude 语句可以忽略依赖项模块 go get 命令可以借助代码管理工具通过远程拉取或更新代码包及其依赖包，并自动完成编译和安装。整个过程就像安装一个 App 一样简单。这个命令在内部实际上分成了两步操作：第一步是下载源码包，第二步是执行 go install。
    </div>
  </div>
</div>

        </div>
      
        <div class="relative w-100 w-30-l mb4 bg-white">
          <div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="/liuyy/posts/%E5%9C%A8c&#43;&#43;%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%98%B2%E6%AD%A2%E5%A4%B4%E6%96%87%E4%BB%B6%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98/" class="link black dim">
        在c/c&#43;&#43; 项目中防止头文件重复包含问题
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      在c/c++ 项目中防止头文件重复包含问题 1、头文件重复包含的问题 头文件重复包含会导致重复定义（重复定义可以是变量也可以是函数等），最后导致编译报错。
在c/c++中，声明和定义是完全不同的
声明：声明是指出变量存储类型，并声明其名字
定义：为变量分配存储空间，还可为变量指定初始值
extern关键字标识的才是声明，其余都是定义
例如：extern int val; // 声明
int val; // 定义
extern int val = 1;//定义
2、解决方法 使用条件编译 （#ifndef #define #endif )
优点：粒度细，可以精细到具体代码片段， 缺点：但是因为每次都要查看文件是否已有宏定义，效率较低 使用预编译命令(#pragma once)
优点：只需在文件开头加上 #pragma once 即可，效率较高，由编译器保证文件不会重复包含
缺点：粒度较粗，只能针对整个文件，并且只能保证物理文件不重复包含，但是如果有多个拷贝，还是有重复包含的可能性，有些编译器不支持
混合使用
同时结合其优缺点，对于粒度细的控制，使用条件编译，不特殊情况，可以使用#pragma once 3、其他 在编写c/c++ 项目时，因为标准库文件都做了防止重复包含工作，所以只需将自己编写的头文件进行条件编译或者开头加上#pragma once 即可。
    </div>
  </div>
</div>

        </div>
      
    </section></article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://qiaoqiao321.github.io/liuyy/" >
    &copy;  My Blog 2022 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
